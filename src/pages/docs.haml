:plain
  <div style="float:right; border:solid 1px; padding: 0.2em;">
    <p>Also check out:</p>
    <ul>
      <li><a href="/docs/yardoc/FAQ.md.html">The FAQ</a></li>
      <li><a href="/docs/yardoc/HAML_REFERENCE.md.html">The full Haml reference</a></li>
      <li><a href="/docs/yardoc/">The YARD documentation</a></li>
    </ul>
  </div>

  <div id='content'>
        <div id='description'>
          <h1>Haml and Sass</h1>
          <p>
          Haml and Sass are templating engines for the two
          most common types of documents on the web: HTML and CSS, respectively. They
          are designed to make it both easier and more pleasant to code HTML and CSS
          documents, by eliminating redundancy, reflecting the underlying structure
          that the document represents, and providing elegant, easily understandable,
          and powerful syntax.
          </p>

          <h2>Using</h2>
          <p>
          There are several ways to use Haml and
          Sass. They can be used as a plugins for
          Rails or Merb, or embedded on their own
          in other applications. The first step of all of these is to install the Haml gem:
          </p>

          <pre>  gem install haml</pre>
          <p>
          To install Haml and Sass as a Rails plugin, just run <tt>haml
          --rails path/to/rails/app</tt> and both Haml and Sass will be installed. Views with the
          <tt>.haml</tt> (or <tt>.html.haml</tt> for edge) extension will
          automatically use Haml. Sass is a little more complicated;
          <tt>.sass</tt> files should be placed in public/stylesheets/sass, where
          they&#8216;ll be automatically compiled to corresponding CSS files in
          public/stylesheets when needed (the Sass

          template directory is customizable&#8230; see the Sass module docs for details).
          </p>
          <p>
          For Merb, <tt>.html.haml</tt> views will
          work without any further modification. To enable Sass, you also need to add it add a
          dependency. To do so, just add
          </p>

          <pre>  dependency &quot;haml&quot;</pre>
          <p>
          to config/dependencies.rb. Then it&#8216;ll work just like it does in
          Rails.
          </p>
          <p>
          To use Haml and Sass programatically, check out the RDocs
          for the Haml and Sass modules.
          </p>

          <h2>Formatting</h2>
          <h3>Haml</h3>
          <p>
          The most basic element of Haml is a
          shorthand for creating HTML tags:
          </p>
          <pre>  %tagname{ :attr1 =&gt; 'value1', :attr2 =&gt; 'value2' } Contents</pre>

          <p>
          No end-tag is needed; Haml handles that
          automatically. Adding <tt>class</tt> and <tt>id</tt> attributes is even
          easier. Haml uses the same syntax as the
          CSS that styles the document:
          </p>

          <pre>  %tagname#id.class</pre>
          <p>
          In fact, when you&#8216;re using the <tt>&lt;div&gt;</tt> tag, it becomes
          <em>even easier</em>. Because <tt>&lt;div&gt;</tt> is such a common
          element, a tag without a name defaults to a div. So
          </p>

          <pre>  #foo Hello!</pre>
          <p>
          becomes
          </p>
          <pre>  &lt;div id='foo'&gt;Hello!&lt;/div&gt;</pre>
          <p>

          Haml uses indentation to bring the
          individual elements to represent the HTML structure. A tag&#8216;s children
          are indented two spaces more than the parent tag. Again, a closing tag is
          automatically added. For example:
          </p>
          <pre>  %ul&#x000A;    %li Salt&#x000A;    %li Pepper</pre>
          <p>
          becomes:
          </p>

          <pre>  &lt;ul&gt;&#x000A;    &lt;li&gt;Salt&lt;/li&gt;&#x000A;    &lt;li&gt;Pepper&lt;/li&gt;&#x000A;  &lt;/ul&gt;</pre>
          <p>
          You can also put plain text as a child of an element:
          </p>

          <pre>  %p&#x000A;    Hello,&#x000A;    World!</pre>
          <p>
          It&#8216;s even possible to embed Ruby code into Haml documents. An equals sign, <tt>=</tt>,
          will output the result of the code. A hyphen, <tt>-</tt>, will run the code
          but not output the result. You can even use control statements like
          <tt>if</tt> and <tt>while</tt>:
          </p>

          <pre>  %p&#x000A;    Date/Time:&#x000A;    - now = DateTime.now&#x000A;    %strong= now&#x000A;    - if now &gt; DateTime.parse(&quot;December 31, 2006&quot;)&#x000A;      = &quot;Happy new &quot; + &quot;year!&quot;</pre>

          <p>
          Haml provides far more tools than those
          presented here. Check out the reference documentation in the Haml module.
          </p>
          <h3>Sass</h3>
          <p>
          At its most basic, Sass is just another
          way of writing CSS. Although it&#8216;s very much like normal CSS, the
          basic syntax offers a few helpful features: tabulation (using *two spaces*)
          indicates the attributes in a rule, rather than non-DRY brackets; and
          newlines indicate the end of an attribute, rather than a semicolon. For
          example:
          </p>

          <pre>  #main&#x000A;    :background-color #f00&#x000A;    :width 98%</pre>
          <p>
          becomes:
          </p>
          <pre>  #main {&#x000A;    background-color: #f00;&#x000A;    width: 98% }</pre>

          <p>
          However, Sass provides much more than a
          way to make CSS look nice. In CSS, it&#8216;s important to have accurate
          selectors, so your styles don&#8216;t just apply to everything. However, in
          order to do this, you need to use nested element selectors. These get very
          ugly very quickly. I&#8216;m sure everyone&#8216;s had to write something
          like &quot;main .sidebar .top p h1 a&quot;, followed by &quot;main .sidebar
          .top p h1 a:visited&quot; and &quot;main .sidebar .top p h1 a:hover&quot;.
          Well, Sass gets rid of that. Like Haml, it uses indentation to indicate the
          structure of the document. So, what was:
          </p>

          <pre>  #main {&#x000A;    width: 90%;&#x000A;  }&#x000A;  #main p {&#x000A;    border-style: solid;&#x000A;    border-width: 1px;&#x000A;    border-color: #00f;&#x000A;  }&#x000A;  #main p a {&#x000A;    text-decoration: none;&#x000A;    font-weight: bold;&#x000A;  }&#x000A;  #main p a:hover {&#x000A;    text-decoration: underline;&#x000A;  }</pre>

          <p>
          becomes:
          </p>
          <pre>  #main&#x000A;    :width 90%&#x000A;    p&#x000A;      :border-style solid&#x000A;      :border-width 1px&#x000A;      :border-color #00f&#x000A;      a&#x000A;        :text-decoration none&#x000A;        :font-weight bold&#x000A;      a:hover&#x000A;        :text-decoration underline</pre>

          <p>
          Pretty nice, no? Well, it gets better. One of the main complaints against
          CSS is that it doesn&#8216;t allow constants. What if have a color or a
          width you re-use all the time? In CSS, you just have to re-type it each
          time, which is a nightmare when you decide to change it later. Not so for
          Sass! You can use the &quot;!&quot;
          character to set constants. Then, if you put &quot;=&quot; after your
          attribute name, you can set it to a constant. For example:
          </p>
          <pre>  !note_bg= #55aaff&#x000A;&#x000A;  #main&#x000A;    :width 70%&#x000A;    .note&#x000A;      :background-color= !note_bg&#x000A;    p&#x000A;      :width 5em&#x000A;      :background-color= !note_bg</pre>

          <p>
          becomes:
          </p>
          <pre>  #main {&#x000A;    width: 70%; }&#x000A;    #main .note {&#x000A;      background-color: #55aaff; }&#x000A;    #main p {&#x000A;      width: 5em;&#x000A;      background-color: #55aaff; }</pre>

          <p>
          You can even do simple arithmetic operations with constants, adding numbers
          and even colors together:
          </p>
          <pre>  !main_bg= #46ar12&#x000A;  !main_width= 40em&#x000A;&#x000A;  #main&#x000A;    :background-color= !main_bg&#x000A;    :width= !main_width&#x000A;    .sidebar&#x000A;      :background-color= !main_bg + #333333&#x000A;      :width= !main_width - 25em</pre>

          <p>
          becomes:
          </p>
          <pre>  #main {&#x000A;    background-color: #46a312;&#x000A;    width: 40em; }&#x000A;    #main .sidebar {&#x000A;      background-color: #79d645;&#x000A;      width: 15em; }</pre>

          <p>
          Taking the idea of constants a bit further are mixins. These let you group
          whole swathes of CSS attributes into a single directive and then include
          those anywhere you want:
          </p>
          <pre>  =blue-border&#x000A;    :border&#x000A;      :color blue&#x000A;      :width 2px&#x000A;      :style dotted&#x000A;&#x000A;  .comment&#x000A;    +blue-border&#x000A;    :padding 2px&#x000A;    :margin 10px 0&#x000A;&#x000A;  .reply&#x000A;    +blue-border</pre>

          <p>
          becomes:
          </p>
          <pre>  .comment {&#x000A;    border-color: blue;&#x000A;    border-width: 2px;&#x000A;    border-style: dotted;&#x000A;    padding: 2px;&#x000A;    margin: 10px 0;&#x000A;  }&#x000A;&#x000A;  .reply {&#x000A;    border-color: blue;&#x000A;    border-width: 2px;&#x000A;    border-style: dotted;&#x000A;  }</pre>

          <p>
          A comprehensive list of features is in the documentation for the Sass module.
          </p>
          <h2>Executables</h2>
          <p>
          The Haml gem includes several
          executables that are useful for dealing with Haml and Sass from the command line.
          </p>

          <h3><tt>haml</tt></h3>
          <p>
          The <tt>haml</tt> executable transforms a source Haml file into HTML. See <tt>haml
          --help</tt> for further information and options.
          </p>

          <h3><tt>sass</tt></h3>
          <p>
          The <tt>sass</tt> executable transforms a source Sass file into CSS. See <tt>sass
          --help</tt> for further information and options.
          </p>

          <h3><tt>html2haml</tt></h3>
          <p>
          The <tt>html2haml</tt> executable attempts to transform HTML, optionally
          with ERB markup, into Haml code. Since
          HTML is so variable, this transformation is not always perfect; it&#8216;s
          a good idea to have a human check the output of this tool. See

          <tt>html2haml --help</tt> for further information and options.
          </p>

          <h3><tt>css2sass</tt></h3>
          <p>
          The <tt>css2sass</tt> executable attempts to transform CSS into Sass code. This transformation attempts to
          use Sass nesting where possible. See
          <tt>css2sass --help</tt> for further information and options.
          </p>

          <h2>Authors</h2>
          <p>
          Haml and Sass are designed by Hampton Catlin
          (hcatlin) and he is the author of the original implementation. However,
          Hampton doesn&#8216;t even know his way around the code anymore and mostly
          just concentrates on the language issues. Hampton lives in Toronto, Ontario
          (though he&#8216;s an American by birth) and is a partner at Unspace
          Interactive.
          </p>
          <p>

          Nathan Weizenbaum is the primary maintainer and architect of the
          &quot;modern&quot; Ruby implementation of Haml. His hard work has kept the project
          alive by endlessly answering forum posts, fixing bugs, refactoring, finding
          speed improvements, writing documentation, implementing new features, and
          getting Hampton coffee (a fitting task for a boy-genius). Nathan lives in
          Seattle, Washington and while not being a student at University of
          Washington he consults for Unspace Interactive and Microsoft.
          </p>
          <p>
          If you use this software, you must pay Hampton a compliment. And buy Nathan
          some jelly beans. Maybe pet a kitten. Yeah. Pet that kitty.
          </p>
          <p>
          Some of the work on Haml was supported
          by Unspace Interactive.
          </p>

          <p>
          Beyond that, the implementation is licensed under the MIT License. Ok,
          fine, I guess that means compliments aren&#8216;t <b>required</b>.
          </p>
        </div>
        <div id='section'>
        </div>
      </div>
